;*************************************
;
; ATARI 1050 DISK DRIVE INTERFACE
;
; COPYRIGHT 1985 (C) BY EMC
;
; 2793/2797 VERSION
; REVISION 1.10
; REVISION 2.02
; REVISION 2.20
; REVISION 2.30
; REVISION 2.31
; REVISION 2.40
; REVISION 3.00 FIXED TRACK 0 CAL PROB
; REVISION 3.10 MADE UNBUFFERD DEFAULT
; LAST UPDATED FEB 21, 1987
;
;**************************************
;
;
;SYSTEM CONSTANTS
;
;
DRA	=	$0280	;6532 DATA REGISTER
DDRA	=	$0281	;DATA DIREC. REG A
DRB	=	$0282	;DATA REGISTER B
DDRB	=	$0283	;DATA DIREC REG B
RTDE	=	$0284	;READ TIMER DISABLE IRQ
WT24E	=	$029F	;WRITE TIMER ENABLE INT.
WT64D	=	$0296	;WRITE TIMER DISABLE INT.

;**************************************
;
; BIT ASSIGNMENTS
;PORT A:
;     D0:SELECT SWITCH
;     D1:SELECT SWITCH
;     D2:NOT USED
;     D3:N MOTOR CONTROL
;     D4:WRITE PRE COMPENSATE
;     D5:FDC DOUBLE DENSITY
;     D6:6532 IRQ
;     D7:FDC DATA REQUEST
;
;PORT B:
;     D0:DATA OUT
;     D1:VCC READY
;     D2:NS04
;     D3:NS03
;     D4:NS02
;     D5:NS01
;     D6:DATA IN
;     D7:CMD
;
;**************************************

STREG	=	$0400	;FDC STATUS REGISTER
CMDREG	=	$0400	;FDC COMMAND REGISTER
TRKREG	=	$0401	;FDC TRACK REGISTER
SECREG	=	$0402	;FDC SECTOR REGISTER
DTAREG	=	$0403	;FDC DATA REGISTER


;PAGE ZERO VALUES

ZERO	=	$00	;START OF PAGE ZERO
;
;GLOBAL VARIABLES
;THESE SHOULD BE SET BY ONE ROUTINE
;BUT CAN BE READ BY ALL
	* =	0
;
CSELXX	.DS	2	;COMMAND CONTINUATION
			;VECTOR
			;INITIALIZED TO POINT
			;TO CMDNAK.  USRE RESETS
			;TO POINT TO OWN
			;COMMAND DECODE
			;ROUTINE
;
;VARIABLES USED BY GET
;
GCNT	.DS	1	;GET COUNT
FLAG	.DS	1	;USED BY GET
;
;VARIABLES USE BY CSUM
;
CHKSUM	.DS	1	;CHECKSUM 1 BYTE
;
;VARIALBES USED BY RCMDFRM
;
;************************************
;
; CMDFRM:DEVICE SELECT CODE
;     +1:COMMAND BYTE
;     +2:DAUX1 FROM SIO
;     +3:DAUX2 FROM SIO
;     +4:CHECKSUM FROM SIO
;
;************************************
;
CMDFRM	.DS	4	;COMMAND FRAM BUFFER
;
TRACK	.DS	1	;CURRERT TRACK
NTRK	.DS	1	;NEW TRACK TO READ
NSEC	.DS	1	;NEW SECTOR TO READ
STRADR	.DS	2	;POINTER TO START LOADING
			;PROGRAM DATA INTO RAM
TC	.DS	1	;TIMER COUNT FOR 5 SEC
MFLAG	.DS	1	;MOTOR ON FLAG
TINB	.DS	1	;TRACK IN BUFFER

;
STAT	.DS	4
;
;
;************************************
;
; STATUS BYTES:
; STAT:
; STAT+1:
; STAT+2:
; STAT+3:
;
;************************************
;
;
TEMP	.DS	1	;TEMP BYTE LOCATION
BPNT	.DS	2	;SECTOR BUFFER POINTER
LENTH	.DS	1	;DATA PARAMETER FOR SEND
;
CONFIG	.DS	12	;12 BYTES FOR DATA CONTROL
DRCLSD	.DS	1	;FF WHEN CLOSED
SECT	.DS	1
TRCK	.DS	1
BASE	.DS	2
BPNT1	.DS	2	;2 BYTES
TRKCH	.DS	26	;18 BYTE SECTOR OK ARRAY
;
;GLOBAL
;VARIABLES USED BY ACTION RUNTIME
;LIBRARY FUNCTIONS
;
SIGN	.DS	1	;ONE BYTE FOR SIGN INFO
ATMP	.DS	2	;TEMP LOCATION FOR MATH
TNPNT	.DS	52	;EXTRA SPACE FOR TRACK NUM
			;POINTERS
TL	.DS	1	;TIME LIMIT FOR MOTOR HANG ON
TFLAG	.DS	1	;TRACK BUFFER ENABLE FLAG
BCNT	.DS	1	;BUFFER COUNT FOR SPECIAL
			;COPY ROUTINES
CFMTBF	.DS	2	;BUFFER FOR CUSTOM FORMAT
;
	* =	$88
;
GET	.DS	3	;PROGRAMABLE JUMP VECTOR
			;FOR THE GET ROUTINE
PUT	.DS	3	;PROGRAMABLE JUMP VECTOR
			;FOR THE PUT ROUTINE
CMDRT	.DS	1	;COMMAND RETRY COUNT
SSTAT	.DS	1	;BUAD RATE STAT 0=USPEED
CSERCT	.DS	1	;CHECK SUM ERROR COUNT
TADRES	.DS	6	;SIX BYTES TRACK ADDRESS
FDCFLG	.DS	1	;INDCATES FDC TYPE FOUND
RSECCM	.DS	1	;READ SECTOR COMMAND
WSECCM	.DS	1	;WRITE SECTOR COMMAND
WSDMCM	.DS	1	;WRITE SECTOR DEL DATA
DCKFLG	.DS	1	;DENSITY CHECK INHIBIT
SRATE	.DS	1	;STEP RATE
STPPOS	.DS	1	;STEPPER POSSITION
;
	* =	$B0
;
SKTAB	.DS	26	;SKEW TABLE FOR RDTK
;
;
BUFF	=	$2000	;256 BYTE BUFFER I/O
;
;
;	ORG	$4000	;ADDRESS TO LOAD INTO RAM
;			;WHEN USING DEBUG, ETC.
;	LOC	$E000	;RUN LOCATION FOR CODE
;			;THIS ALLOWS US TO ROM CODE
	* = 	$E000
;
;**************************************
;
;JUMP VECTOR TABLE
; THIS IS WHERE USER PROGRAMS CALL TO
; ACCESS THE VARIOUS UTILITIES IN THIS
; PROGRAM
; THESE WILL BE THE ONLY DOCUMENTED
; ENTRY POINTS INTO THE SYSTEM
;
;**************************************
;
VECTAB	JMP	START	;COLDSTART
NAKV	JMP	NAK	;SEND NOT ACKKNOLEDGE
ERRV	JMP	ERR	;SEND ERROR CODE BACK
ACKV	JMP	ACK	;SEND ACK BACK
CMPLV	JMP	CMPLT	;SEND COMPLETE BACK
DELV	JMP	DELAY	;DO 250 USEC DELAY
GETV	JMP	GET	;GET DATA FROM SERIAL BUS
PUTV	JMP	PUT	;PUT BYTE TO ATARI
CSUMV	JMP	CSUM	;COMPUT CHECKSUM
READV	JMP	READ	;GET DATA FROM ATARI
			;ALSO CHECKS THE CHECK SUM
SENDV	JMP	SEND	;SEND BUFFER BACK TO 
			;ATARI WITH A CHECKSUM
FINTV	JMP	FINT	;FDC FORCE INTERRUPT
MULTV	JMP	MULT	;PERFORM 8 BY 8 MULTIPLY
TRK0V	JMP	TRK0	;RECAL HEAD POSITION
WT5MSV	JMP	SWAIT	;5 MSEC DELAY
SKTKV	JMP	SKTK	;SEEK TRACK
NTSV	JMP	NTS	;CALCULATE NEW TRACK FROM
			;DATA IN COMMAND FRAME
RSECV	JMP	RSEC	;READ SECTOR ON CURRENT
			;TRACK
VSECV	JMP	VSEC	;VERIFY SECTOR ON
			;CURRENT TRACK
WSECV	JMP	WSEC	;WRITE SECTOR TO CURRENT
			;TRACK
RDTKV	JMP	RDTK	;READ ALL SECTORS ON
			;CURRENT TRACK AND
			;PUT THEM IN TRACK
			;BUFFER
SBPNTV	JMP	SBPNT	;SET SECTOR BUFFER
			;POINTER
RDSCV	JMP	RDSC	;SEND DATA IN TRACK
			;TRACK BUFFER THAT
			;CORRESPONDS TO
			;SECTOR NUMBER
MOONV	JMP	MOON	;TURN MOTOR ON
MOOFFV	JMP	MOOFF	;TURN MOTOR OFF
;
VCMDXT	JMP	CMDXIT
VCMDNK	JMP	CMDNAK
VCMDER	JMP	CMDERR
;
;
;ACTION RUNTIME VECTORS
;
LSHV	JMP	LSH	;LEFT SHIFT
RSHV	JMP	RSH	;RIGHT SHIFT
MLTV	JMP	MLTI	;MULTIPLY
DIVV	JMP	DIVI	;DIVIDE
SARGV	JMP	SARGS	;PASS ARGUMENTS
LOWV	JMP	LOWB	;RETURN LOW BYTE
HIV	JMP	HIB	;RETURN HIGH BYTE
;
;MORE ENTRYS
;
CSSKV	JMP	CSSK
REVTV	JMP	REVT
CKBFV	JMP	CKBF
DLNTRV	JMP	DLNTRY
RTATV	JMP	RTAT	;ROTOTE SECTOR MAP BUFF
CMPV	JMP	CMPP
CRCV	JMP	CRC	;CALLS ABOVE WCEV
SRTV	JMP	SRT	;SPECIAL READ TRACK
ZABV	JMP	ZAB	;ZERO A BUFFER
SWSV	JMP	SWS	;WRITE A DELETED DATA MARK
SRDAV	JMP	SRDA	;SPECIAL READ ADDRESS
BBV	JMP	BB	;BUILD A BLOCK OF DATA
DFLTSV	JMP	DFLTS	;SET SKEW DEFAULTS
RADRV	JMP	RADR	;READ ADDRESS
;
;
;*************************************
;
; RUNTIME LIBRARY FUNCTION FOR ACTION!
;
; RSH
; LSH
; MULT
; DIV
; MOD
; SARGS
;
;*************************************
;
LSH
;	PROC
.local
;
;THIS ROUTINE WILL SHIFT A NUMBER LEFT
;
?SHIFT	=	$84	;NUMBER OF BYTES TO SHIFT
?MSB	=	$85	;MOST SIG BYTE TO SHIFT
;
	LDY	?SHIFT	;ARE WE SHIFTING BY ZERO
	BEQ	?LSHXT	;YES, JUST EXIT
	STX	?MSB	;STORE MOST SIGNIFICANT BYTE
?LOOP	ASL	A	;SHIFT LSB
	ROL	?MSB	;SHIFT MSB
	DEY	;DECREMENT SHIFT
	BNE	?LOOP	;KEEP ON GOING
	LDX	?MSB	;RETURN MSB IN XREG
?LSHXT	RTS
;	EPROC
;
;
RSH
;	PROC
.local	;RIGHT SHIFT FUNCTION
;
?SHIFT	=	$84	;AMOUNT TO SHIFT BY
?MSB	=	$85	;MOST SIG BYTE
;
	LDY	?SHIFT	;IS SHIFT = 0?
	BEQ	?RSHXT	;YES EXIT
	STX	?MSB
?LOOP	LSR	?MSB	;SHIFT MOST SIG BYTE
	ROR	A	;SHIFT LSB
	DEY	;DECREMENT SHIFT
	BNE	?LOOP
	LDX	?MSB	;RETURN MSB IN X REG
?RSHXT	RTS
;
SSNG
;	PROC
.local	;SET SIGN
;
?OP3	=	$86
;
	LDY	SIGN
	BPL	?SS08	
SS1	STA	?OP3
	STX	?OP3+1
	SEC
	LDA	#$00
	SBC	?OP3
	TAY
	LDA	#$00
	SBC	?OP3+1
	TAX
	TYA
?SS08	RTS
;	EPROC

SMOPS
;	PROC
.local
;
?OP1	=	$82
?OP2	=	$84
?OP3	=	$86
;
	STX	SIGN
	CPX	#$00
	BPL	?SM11
	JSR	SS1
?SM11	STA	?OP1
	STX	?OP1+1
	LDA	?OP2+1
	BPL	?SM15
	TAX
	EOR	SIGN
	STA	SIGN
	LDA	?OP2
	JSR	SS1	;SET SIGN
	STA	?OP2
	STX	?OP2+1
?SM15	LDA	#$00
	STA	?OP3+1
	RTS
;	EPROC
;
MLTB
;	PROC
.local
;
?OP1	=	$82
?OP2	=	$84
?OP3	=	$86
;
	BEQ	?MB16
	DEX
	STX	ATMP+1
	TAX
	BEQ	?MB16
	STX	ATMP
	LDA	#$00
	LDX	#$08
?MB20	ASL	A
	ASL	ATMP
	BCC	?MB19
	ADC	ATMP+1
?MB19	DEX
	BNE	?MB20
	CLC
	ADC	?OP3+1
	STA	?OP3+1
?MB16	LDA	?OP3
	LDX	?OP3+1
	RTS
;	EPROC
;
MLTI
;	PROC
.local
;
?OP1	=	$82
?OP2	=	$84
?OP3	=	$86
;
	JSR	SMOPS
	LDX	?OP1
	BEQ	?MI22
	STX	ATMP
	LDX	?OP2
	BEQ	?MI22
	DEX
	STX	ATMP+1
	LDX	#$08
?MI24	ASL	A
	ROL	?OP3+1
	ASL	ATMP
	BCC	?MI23
	ADC	ATMP+1
	BCC	?MI23
	INC	?OP3+1
?MI23	DEX
	BNE	?MI24
?MI22	STA	?OP3
	LDA	?OP1
	LDX	?OP2+1
	JSR	MLTB
	LDA	?OP1+1
	LDX	?OP2
	JSR	MLTB
	JMP	SSNG
;	EPROC
;
;DIVIDE TWO NUMBERS
;
DIVI
;	PROC
.local
;
?OP1	=	$82
?OP2	=	$84
?OP3	=	$86
;
	JSR	SMOPS
	LDA	?OP2+1
	BEQ	?DI27
	LDX	#$08
?DI29	ROL	?OP1
	ROL	?OP1+1
	ROL	?OP3+1
	SEC
	LDA	?OP1+1
	SBC	?OP2
	TAY
	LDA	?OP3+1
	SBC	?OP2+1
	BCC	?DI28
	STA	?OP3+1
	STY	?OP1+1
?DI28	DEX
	BNE	?DI29
	LDA	?OP1
	ROL	A
	LDX	#$00
	LDY	?OP1+1
	STY	?OP3
	JMP	SSNG
?DI27	LDX	#$10
?DI32	ROL	?OP1
	ROL	?OP1+1
	ROL	A
	BCS	?DI30
	CMP	?OP2
	BCC	?DI31
?DI30	SBC	?OP2
	SEC
?DI31	DEX
	BNE	?DI32
	ROL	?OP1
	ROL	?OP1+1
	STA	?OP3
	LDA	?OP1
	LDX	?OP1+1
	JMP	SSNG
;	EPROC
;
; DO MOD FUNCTION
;
MODI
;	PROC
.local
;
?RMDR	=	$86	;REMAINDER
	JSR	DIVI	;DO DIVISION
	LDA	?RMDR	;RETURN LO BYTE IN ACC
	LDX	?RMDR+1	;RETURN HI BYTE IN X REG
	RTS
;	EPROC
;
; PASS PARAMETERS BETWEEN FUNCTIONS
;
SARGS
;	PROC
.local
;
?PRAMS	=	$A0	;SIXTEEN BYTES
?TEMP	=	$84	;TWO BYTES
?PPNT	=	$82
;
	STA	?PRAMS	;STORE PARAMS STORED IN
	STX	?PRAMS+1	;A,X,Y REGISTERS
	STY	?PRAMS+2
	CLC	;PREPARE TO ADD
	PLA	;POP RETURN ADDRESS FROM STACK
	STA	?TEMP	;STORE IN TEMP LOCATION
	ADC	#$03	;CALCULATE NEW RETURN ADDRESS
	TAY	;TO BRANCH AROUND POINTER TO
	PLA	;PASSED PARAMETERS
	STA	?TEMP+1	;$0085
	ADC	#$00
	PHA	;PUSH NEW RETRUN ADDRESS ON STACK
	TYA
	PHA
	LDY	#$01	;POINT TO PARAMETERS AREA
	LDA	(?TEMP),Y	;LOW BYTE OF POINTER
	STA	?PPNT
	INY
	LDA	(?TEMP),Y	;HIGH BYTE OF POINTER
	STA	?PPNT+1
	INY
	LDA	(?TEMP),Y	;NUMBER OF PARAMETERS
	TAY
?LOOP	LDA	?PRAMS,Y	;TRANSFER FROM
	STA	(?PPNT),Y	;TEMPORARY TO LOCAL
	DEY	;PARAMETER AREA
	BPL	?LOOP
	RTS
;	EPROC
;
;**************************************
; THESE ARE OTHER USEFUL ACTION!
; FUNCTIONS
;
;**************************************
;
;RETRUN LSB OF A CARD
;
HIB
;	PROC
.local
;
?RES	=	$A0
;
	STX	?RES
	RTS
;	EPROC
;
;RETURN HIGH BYTE OF A CARD
;
LOWB
;	PROC
.local
;
?RES	=	$A0
;
	STA	?RES
	RTS
;	EPROC
;
;
	.include	"DD15M1.ASM"
